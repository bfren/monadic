// Wrap: .NET monads for functional style.
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2019

using System;
using System.Threading.Tasks;
using Wrap.Exceptions;

namespace Wrap;

public static partial class E
{
	#region Without Return Value

	/// <summary>
	/// Run an action based on the value of <paramref name="either"/>.
	/// </summary>
	/// <remarks>
	/// <para>
	/// It would be possible to achieve the same thing using switch statements, but doing that would add the
	/// potential for not handling both cases (<see cref="Right{TLeft, TRight}"/> and <see cref="Left{TLeft, TRight}"/>).
	/// </para>
	/// <para>
	/// This way there has to be a function to handle both cases.
	/// </para>
	/// </remarks>
	/// <typeparam name="TLeft">Left (error / invalid) value type.</typeparam>
	/// <typeparam name="TRight">Right (correct / valid) value type.</typeparam>
	/// <param name="either">Result object.</param>
	/// <param name="left">Function to run when <paramref name="either"/> is <see cref="Left{TLeft, TRight}"/>.</param>
	/// <param name="right">Function to run when <paramref name="either"/> is <see cref="Right{TLeft, TRight}"/>.</param>
	/// <exception cref="InvalidEitherTypeException"></exception>
	/// <exception cref="NullEitherException"></exception>
	public static void Match<TLeft, TRight>(Either<TLeft, TRight> either, Action<TLeft> left, Action<TRight> right)
	{
		Action f = either switch
		{
			Left<TLeft, TRight> x =>
				() => left(x.Value),

			Right<TLeft, TRight> y =>
				() => right(y.Value),

			{ } m =>
				throw new InvalidEitherTypeException(m.GetType()),

			_ =>
				throw new NullEitherException()
		};

		f();
	}

	/// <inheritdoc cref="Match{TLeft, TRight}(Either{TLeft, TRight}, Action{TLeft}, Action{TRight})"/>
	public static Task MatchAsync<TLeft, TRight>(Either<TLeft, TRight> either, Action<TLeft> left, Func<TRight, Task> right) =>
		MatchAsync(either.AsTask(), x => { left(x); return Task.CompletedTask; }, right);

	/// <inheritdoc cref="Match{TLeft, TRight}(Either{TLeft, TRight}, Action{TLeft}, Action{TRight})"/>
	public static Task MatchAsync<TLeft, TRight>(Either<TLeft, TRight> either, Func<TLeft, Task> left, Action<TRight> right) =>
		MatchAsync(either.AsTask(), left, x => { right(x); return Task.CompletedTask; });

	/// <inheritdoc cref="Match{TLeft, TRight}(Either{TLeft, TRight}, Action{TLeft}, Action{TRight})"/>
	public static Task MatchAsync<TLeft, TRight>(Either<TLeft, TRight> either, Func<TLeft, Task> left, Func<TRight, Task> right) =>
		MatchAsync(either.AsTask(), left, right);

	/// <inheritdoc cref="Match{TLeft, TRight}(Either{TLeft, TRight}, Action{TLeft}, Action{TRight})"/>
	public static async Task MatchAsync<TLeft, TRight>(Task<Either<TLeft, TRight>> either, Func<TLeft, Task> left, Func<TRight, Task> right)
	{
		Func<Task> f = await either switch
		{
			Left<TLeft, TRight> x =>
				() => left(x.Value),

			Right<TLeft, TRight> y =>
				() => right(y.Value),

			{ } r =>
				throw new InvalidEitherTypeException(r.GetType()),

			_ =>
				throw new NullEitherException()
		};

		await f();
	}

	#endregion

	#region With Return Value

	/// <summary>
	/// Run a function based on the value of <paramref name="either"/> and return its value.
	/// </summary>
	/// <remarks>
	/// <para>
	/// It would be possible to achieve the same thing using switch statements, but doing that would add the
	/// potential for not handling both cases (<see cref="Right{TLeft, TRight}"/> and <see cref="Left{TLeft, TRight}"/>).
	/// </para>
	/// <para>
	/// This way there has to be a function to handle both cases.
	/// </para>
	/// </remarks>
	/// <typeparam name="TLeft">Left (error / invalid) value type.</typeparam>
	/// <typeparam name="TRight">Right (correct / valid) value type.</typeparam>
	/// <typeparam name="TReturn">Return value type.</typeparam>
	/// <param name="either">Result object.</param>
	/// <param name="left">Function to run when <paramref name="either"/> is <see cref="Left{TLeft, TRight}"/>.</param>
	/// <param name="right">Function to run when <paramref name="either"/> is <see cref="Right{TLeft, TRight}"/>.</param>
	/// <returns>Value generated by either <paramref name="left"/> or <paramref name="right"/>.</returns>
	/// <exception cref="InvalidEitherTypeException"></exception>
	/// <exception cref="NullEitherException"></exception>
	public static TReturn Match<TLeft, TRight, TReturn>(Either<TLeft, TRight> either, Func<TLeft, TReturn> left, Func<TRight, TReturn> right) =>
		either switch
		{
			Left<TLeft, TRight> x =>
				left(x.Value),

			Right<TLeft, TRight> y =>
				right(y.Value),

			{ } r =>
				throw new InvalidEitherTypeException(r.GetType()),

			_ =>
				throw new NullEitherException()
		};

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Either<TLeft, TRight> either, Func<TLeft, TReturn> left, Func<TRight, Task<TReturn>> right) =>
		MatchAsync(either.AsTask(), x => Task.FromResult(left(x)), right);

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Either<TLeft, TRight> either, Func<TLeft, Task<TReturn>> left, Func<TRight, TReturn> right) =>
		MatchAsync(either.AsTask(), left, x => Task.FromResult(right(x)));

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Either<TLeft, TRight> either, Func<TLeft, Task<TReturn>> left, Func<TRight, Task<TReturn>> right) =>
		MatchAsync(either.AsTask(), left, right);

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Task<Either<TLeft, TRight>> either, Func<TLeft, TReturn> left, Func<TRight, TReturn> right) =>
		MatchAsync(either, x => Task.FromResult(left(x)), x => Task.FromResult(right(x)));

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Task<Either<TLeft, TRight>> either, Func<TLeft, TReturn> left, Func<TRight, Task<TReturn>> right) =>
		MatchAsync(either, x => Task.FromResult(left(x)), right);

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Task<Either<TLeft, TRight>> either, Func<TLeft, Task<TReturn>> left, Func<TRight, TReturn> right) =>
		MatchAsync(either, left, x => Task.FromResult(right(x)));

	/// <inheritdoc cref="Match{TLeft, TRight, TReturn}(Either{TLeft, TRight}, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static async Task<TReturn> MatchAsync<TLeft, TRight, TReturn>(Task<Either<TLeft, TRight>> either, Func<TLeft, Task<TReturn>> left, Func<TRight, Task<TReturn>> right) =>
		await Match(await either, left, right);

	#endregion
}
