// Monadic: .NET monads for functional style.
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2019

using System;
using System.Threading.Tasks;
using Monadic.Exceptions;

namespace Monadic;

public static partial class M
{
	#region Without Return Value

	/// <summary>
	/// Run an action based on the value of <paramref name="maybe"/>.
	/// </summary>
	/// <typeparam name="T">Some value type.</typeparam>
	/// <param name="maybe">Maybe object.</param>
	/// <param name="none">Function to run when <paramref name="maybe"/> is <see cref="Monadic.None"/>.</param>
	/// <param name="some">Function to run when <paramref name="maybe"/> is <see cref="Some{T}"/>.</param>
	/// <exception cref="InvalidMaybeTypeException"></exception>
	public static void Switch<T>(Maybe<T> maybe, Action none, Action<T> some)
	{
		var f = maybe switch
		{
			Maybe<T>.None =>
				none,

			Some<T> x =>
				() => some(x.Value),

			{ } x =>
				throw new InvalidMaybeTypeException(x.GetType())
		};

		f();
	}

	/// <inheritdoc cref="Switch{T}(Maybe{T}, Action, Action{T})"/>
	public static Task SwitchAsync<T>(Maybe<T> maybe, Func<Task> none, Func<T, Task> some) =>
		SwitchAsync(Task.FromResult(maybe), none, some);

	/// <inheritdoc cref="Switch{T}(Maybe{T}, Action, Action{T})"/>
	public static async Task SwitchAsync<T>(Task<Maybe<T>> maybe, Func<Task> none, Func<T, Task> some)
	{
		var f = await maybe switch
		{
			Maybe<T>.None =>
				none,

			Some<T> x =>
				() => some(x.Value),

			{ } x =>
				throw new InvalidMaybeTypeException(x.GetType())
		};

		await f();
	}

	#endregion

	#region With Return Value

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static TReturn Switch<T, TReturn>(Maybe<T> maybe, TReturn none, Func<T, TReturn> some) =>
		Switch(maybe, () => none, some);

	/// <summary>
	/// Run a function based on the value of <paramref name="maybe"/> and return its value.
	/// </summary>
	/// <typeparam name="T">Some value type.</typeparam>
	/// <typeparam name="TReturn">Return value type.</typeparam>
	/// <param name="maybe">Maybe object.</param>
	/// <param name="none">Function to run when <paramref name="maybe"/> is <see cref="Monadic.None"/>.</param>
	/// <param name="some">Function to run when <paramref name="maybe"/> is <see cref="Some{T}"/>.</param>
	/// <returns>Value generated by either <paramref name="none"/> or <paramref name="some"/>.</returns>
	/// <exception cref="InvalidMaybeTypeException"></exception>
	public static TReturn Switch<T, TReturn>(Maybe<T> maybe, Func<TReturn> none, Func<T, TReturn> some)
	{
		var f = maybe switch
		{
			Maybe<T>.None =>
				none,

			Some<T> x =>
				() => some(x.Value),

			{ } x =>
				throw new InvalidMaybeTypeException(x.GetType())
		};

		return f();
	}

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Maybe<T> maybe, TReturn none, Func<T, Task<TReturn>> some) =>
		Switch(maybe, () => Task.FromResult(none), some);

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Maybe<T> maybe, Func<TReturn> none, Func<T, Task<TReturn>> some) =>
		Switch(maybe, () => Task.FromResult(none()), some);

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Maybe<T> maybe, Func<Task<TReturn>> none, Func<T, TReturn> some) =>
		Switch(maybe, none, x => Task.FromResult(some(x)));

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Maybe<T> maybe, Func<Task<TReturn>> none, Func<T, Task<TReturn>> some) =>
		Switch(maybe, none, some);

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Task<Maybe<T>> maybe, TReturn none, Func<T, TReturn> some) =>
		SwitchAsync(maybe, () => Task.FromResult(none), x => Task.FromResult(some(x)));

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Task<Maybe<T>> maybe, TReturn none, Func<T, Task<TReturn>> some) =>
		SwitchAsync(maybe, () => Task.FromResult(none), some);

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<TReturn> none, Func<T, TReturn> some) =>
		SwitchAsync(maybe, () => Task.FromResult(none()), x => Task.FromResult(some(x)));

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<TReturn> none, Func<T, Task<TReturn>> some) =>
		SwitchAsync(maybe, () => Task.FromResult(none()), some);

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> SwitchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<Task<TReturn>> none, Func<T, TReturn> some) =>
		SwitchAsync(maybe, none, x => Task.FromResult(some(x)));

	/// <inheritdoc cref="Switch{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static async Task<TReturn> SwitchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<Task<TReturn>> none, Func<T, Task<TReturn>> some)
	{
		var f = await maybe switch
		{
			Maybe<T>.None =>
				none,

			Some<T> x =>
				() => some(x.Value),

			{ } x =>
				throw new InvalidMaybeTypeException(x.GetType())
		};

		return await f();
	}

	#endregion
}
